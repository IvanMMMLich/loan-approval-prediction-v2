"""
Step 1.1: Загрузка данных и первичный анализ
============================================

Цель: Познакомиться с данными, понять их структуру и основные характеристики.

Что делаем:
1. Загружаем train.csv
2. Проверяем размерность (количество строк и столбцов)
3. Смотрим первые строки для понимания структуры
4. Анализируем типы данных (числовые, категориальные)
5. Считаем базовую статистику по числовым признакам
6. Анализируем целевую переменную (дисбаланс классов)
7. Сохраняем результаты в CSV файлы
"""
import pandas as pd
import numpy as np
import os
from pathlib import Path

# =============================================================================
# АВТООПРЕДЕЛЕНИЕ КОРНЯ ПРОЕКТА
# =============================================================================

# Находим корень проекта (там где папка data/)
# __file__ = путь к текущему файлу
# .parent.parent.parent = поднимаемся на 3 уровня вверх
PROJECT_ROOT = Path(__file__).parent.parent.parent

# Переходим в корень проекта
os.chdir(PROJECT_ROOT)

print(f"Рабочая директория: {os.getcwd()}")

# =============================================================================
# НАСТРОЙКИ ПУТЕЙ
# =============================================================================

# Путь к исходным данным
DATA_PATH = 'data/raw/train.csv'

# Путь для сохранения результатов
RESULTS_PATH = 'results/step1_first_look/tables'

# Создаём папку для результатов если её нет
# exist_ok=True означает: не выдавать ошибку если папка уже существует
os.makedirs(RESULTS_PATH, exist_ok=True)

# =============================================================================
# НАЧАЛО АНАЛИЗА
# =============================================================================

print("="*60)
print("STEP 1.1: ЗАГРУЗКА И ПЕРВИЧНЫЙ АНАЛИЗ ДАННЫХ")
print("="*60)

# -----------------------------------------------------------------------------
# 1. ЗАГРУЗКА ДАННЫХ
# -----------------------------------------------------------------------------

print("\n1. Загрузка данных...")

# pd.read_csv() - основная функция pandas для чтения CSV файлов
# Возвращает DataFrame - основная структура данных pandas (таблица)
df = pd.read_csv(DATA_PATH)

print(f" Данные загружены из {DATA_PATH}")

# -----------------------------------------------------------------------------
# 2. РАЗМЕРНОСТЬ ДАННЫХ
# -----------------------------------------------------------------------------

print(f"\n2. Размерность данных:")

# df.shape возвращает кортеж (количество_строк, количество_столбцов)
# :, - форматирование числа с разделителями тысяч (165034 → 165,034)
print(f"   Строк (клиентов): {df.shape[0]:,}")
print(f"   Столбцов (признаков): {df.shape[1]}")

# ВАЖНО: Каждая строка = один клиент
# Каждый столбец = один признак (feature) + целевая переменная (Exited)

# -----------------------------------------------------------------------------
# 3. ПРОСМОТР ПЕРВЫХ СТРОК
# -----------------------------------------------------------------------------

print(f"\n3. Первые 5 строк:")

# df.head() показывает первые N строк (по умолчанию 5)
# Помогает визуально понять структуру данных
print(df.head())

# -----------------------------------------------------------------------------
# 4. ИНФОРМАЦИЯ О ТИПАХ ДАННЫХ
# -----------------------------------------------------------------------------

print(f"\n4. Информация о данных:")

# df.info() выводит:
# - Количество строк
# - Названия всех столбцов
# - Тип данных каждого столбца (int64, float64, object)
# - Количество non-null значений (для поиска пропусков)
# - Использование памяти
df.info()

# -----------------------------------------------------------------------------
# 5. ПРОВЕРКА ПРОПУСКОВ (MISSING VALUES)
# -----------------------------------------------------------------------------

print(f"\n5. Пропуски в данных:")

# df.isna() возвращает DataFrame с True/False (True = пропуск)
# .sum() считает количество True по каждому столбцу
missing = df.isna().sum()

# Проверяем есть ли пропуски вообще
if missing.sum() == 0:
    print("   Пропусков нет!")
else:
    # Выводим только столбцы где есть пропуски (> 0)
    print(missing[missing > 0])

# -----------------------------------------------------------------------------
# 6. БАЗОВАЯ СТАТИСТИКА ПО ЧИСЛОВЫМ ПРИЗНАКАМ
# -----------------------------------------------------------------------------

print(f"\n6. Базовая статистика (числовые признаки):")

# df.describe() считает статистику для всех числовых столбцов:
# - count: количество непустых значений
# - mean: среднее значение
# - std: стандартное отклонение (разброс)
# - min: минимальное значение
# - 25%: первый квартиль (25% данных меньше этого значения)
# - 50%: медиана (половина данных меньше, половина больше)
# - 75%: третий квартиль (75% данных меньше этого значения)
# - max: максимальное значение
stats = df.describe()
print(stats)

# Сохраняем статистику в CSV файл
stats_file = os.path.join(RESULTS_PATH, '01_basic_statistics.csv')
stats.to_csv(stats_file)
print(f"\n Статистика сохранена: {stats_file}")

# -----------------------------------------------------------------------------
# 7. АНАЛИЗ ЦЕЛЕВОЙ ПЕРЕМЕННОЙ (TARGET)
# -----------------------------------------------------------------------------

print(f"\n7. Целевая переменная (loan_status):")

# loan_status - целевая переменная (то, что мы предсказываем):
# 0 = кредит НЕ одобрен (отклонён)
# 1 = кредит одобрен

# value_counts() считает сколько раз встречается каждое значение
target_counts = df['loan_status'].value_counts().sort_index()

# normalize=True преобразует в проценты
target_pct = df['loan_status'].value_counts(normalize=True).sort_index() * 100

print(f"\n   Класс 0 (НЕ одобрен): {target_counts[0]:,} ({target_pct[0]:.2f}%)")
print(f"   Класс 1 (одобрен):    {target_counts[1]:,} ({target_pct[1]:.2f}%)")

# Соотношение классов
ratio = target_counts[0] / target_counts[1]
print(f"   Соотношение: {ratio:.2f}:1")

# Сохраняем
target_df = pd.DataFrame({
    'Class': [0, 1],
    'Count': target_counts.values,
    'Percentage': target_pct.values
})
target_file = os.path.join(RESULTS_PATH, '01_target_distribution.csv')
target_df.to_csv(target_file, index=False)
print(f"\n✅ Распределение таргета сохранено: {target_file}")